function [qMetric, unitType] = bc_runAllQualityMetrics(param, spikeTimes, spikeTemplates, ...
    templateWaveforms, templateAmplitudes, pcFeatures, pcFeatureIdx, savePath)
% JF
% ------
% Inputs
% ------
% param: parameter structure with fields:
%   tauR = 0.0010; %refractory period time (s)
%   tauC = 0.0002; %censored period time (s)
%   maxPercSpikesMissing: maximum percent (eg 30) of estimated spikes below detection 
%       threshold to define timechunks in the recording on which to compute
%       quality metrics for each unit. 
%   minNumSpikes: minimum number of spikes (eg 300) for unit to classify it as good 
%   maxNtroughsPeaks: maximum number of troughs and peaks (eg 3) to classify unit
%       waveform as good
%   somatic: boolean, whether to keep only somatic spikes
%   maxRPVviolations: maximum estimated % (eg 20) of refractory period violations to classify unit as good
%   minAmplitude: minimum amplitude of raw waveform in microVolts to
%       classify unit as good
%   plotThis: boolean, whether to plot figures for each metric and unit - !
%       this will create * a lot * of plots if run on all units - use just
%       for debugging a particular issue / creating plots for one single
%       unit 
%   rawFolder: string containing the location of the raw .dat or .bin file 
%   deltaTimeChunk: size of time chunks to cut the recording in, in seconds
%       (eg 600 for 10 min time chunks or duration of recording if you don't 
%       want time chunks)
%   ephys_sample_rate: recording sample rate (eg 30000)
%   nChannels: number of recorded channels, including any sync channels (eg
%       385)
%   nRawSpikesToExtract: number of spikes to extract from the raw data for
%       each waveform (eg 100)
%   nChannelsIsoDist: number of channels on which to compute the distance
%       metrics (eg 4)
%   computeDistanceMetrics: boolean, whether to compute distance metrics or not
%   isoDmin: minimum isolation distance to classify unit as single-unit
%   lratioMin: minimum l-ratio to classify unit as single-unit
%   ssMin: silhouette score to classify unit as single-unit  
%   computeTimeChunks
%
% spikeTimes: nSpikes × 1 uint64 vector giving each spike time in samples (*not* seconds)
%
% spikeTemplates: nSpikes × 1 uint32 vector giving the identity of each
%   spike's matched template
%
% templateWaveforms: nTemplates × nTimePoints × nChannels single matrix of
%   template waveforms for each template and channel
%
% templateAmplitudes: nSpikes × 1 double vector of the amplitude scaling factor
%   that was applied to the template when extracting that spike
%
% pcFeatures: nSpikes × nFeaturesPerChannel × nPCFeatures  single 
%   matrix giving the PC values for each spike
%
% pcFeatureIdx: nTemplates × nPCFeatures uint32  matrix specifying which 
%   channels contribute to each entry in dim 3 of the pc_features matrix
%
% ------
% Outputs
% ------
% qMetric: structure with fields:
%   percSpikesMissing
%   useTheseTimes
%   nSpikes
%   nPeaks
%   nTroughs
%   somatic
%   Fp
%   rawAmplitude
%   spatialDecay
%   isoD
%   Lratio
%   silhouetteScore
% 
% unitType: nUnits x 1 vector indicating whether each unit met the
%   threshold criterion to be classified as a single unit (1), noise
%   (0) or multi-unit (2) 

%% if some manual curation already performed, remove bad units 

%% prepare for quality metrics computations: get waveform max_channel and raw waveforms
qMetric = struct;
maxChannels = bc_getWaveformMaxChannel(templateWaveforms);
qMetric.maxChannels = maxChannels; 

verbose=1;
qMetric.rawWaveforms = bc_extractRawWaveformsFast(param.rawFolder, param.nChannels, param.nRawSpikesToExtract, ...
   spikeTimes, spikeTemplates, verbose); % takes ~10' - QQ but bug in this
%    method I need to fix, reverting back to slow method for now
% [qMetric.rawWaveforms, qMetric.rawMemMap] = bc_extractRawWaveforms(param.rawFolder, param.nChannels, param.nRawSpikesToExtract, ...
%     spikeTimes, spikeTemplates, usedChannels, verbose);

%% loop through units and get quality metrics

uniqueTemplates = unique(spikeTemplates);
spikeTimes = spikeTimes ./ param.ephys_sample_rate; %convert to seconds after using sample indices to extract raw waveforms
if param.computeTimeChunks
    timeChunks = min(spikeTimes):param.deltaTimeChunk:max(spikeTimes);
else
    timeChunks = [min(spikeTimes), max(spikeTimes)];
end

for iUnit = 1:length(uniqueTemplates)
    clearvars thisUnit theseSpikeTimes theseAmplis
    thisUnit = uniqueTemplates(iUnit);
    qMetric.clusterID(iUnit) = thisUnit;
    theseSpikeTimes = spikeTimes(spikeTemplates == thisUnit);
    theseAmplis = templateAmplitudes(spikeTemplates == thisUnit);

    %% percentage spikes missing
    [percSpikesMissing, qMetric.ampliBinCenters{iUnit}, qMetric.ampliBinCounts{iUnit}, qMetric.ampliFit{iUnit}] = ...
        bc_percSpikesMissing(theseAmplis, theseSpikeTimes, timeChunks, param.plotThis);

    %% define timechunks to keep
    if param.computeTimeChunks
        [qMetric.percSpikesMissing(iUnit), theseSpikeTimes, ~, timeChunks, qMetric.useTheseTimes{iUnit}] = bc_defineTimechunksToKeep(percSpikesMissing, ...
            param.maxPercSpikesMissing, theseAmplis, theseSpikeTimes, timeChunks);
    else
        qMetric.percSpikesMissing(iUnit) = percSpikesMissing;
    end
    %% number spikes
    qMetric.nSpikes(iUnit) = bc_numberSpikes(theseSpikeTimes);

    %% waveform: number peaks/troughs and is peak before trough (= axonal/dendritic)
    [qMetric.nPeaks(iUnit), qMetric.nTroughs(iUnit), qMetric.somatic(iUnit), ...
        qMetric.peakLocs{iUnit}, qMetric.troughLocs{iUnit}] = bc_troughsPeaks(templateWaveforms(thisUnit, :, maxChannels(thisUnit)), ...
        param.ephys_sample_rate, param.plotThis);

    %% fraction contam (false postives)
    [qMetric.Fp(iUnit), ~, ~] = bc_fractionRPviolations(numel(theseSpikeTimes), theseSpikeTimes, param.tauR, param.tauC, ...
        timeChunks(end)-timeChunks(1), param.plotThis);

    %% amplitude
    if size(qMetric.rawWaveforms(iUnit).spkMapMean,1) ==1
        qMetric.rawWaveforms(iUnit).spkMapMean = permute(squeeze(qMetric.rawWaveforms(iUnit).spkMapMean),[2,1]);
    end
    qMetric.rawAmplitude(iUnit) = bc_getRawAmplitude(qMetric.rawWaveforms(iUnit).spkMapMean(qMetric.rawWaveforms(iUnit).peakChan, :), ...
        param.rawFolder);

    %% distance metrics
    if param.computeDistanceMetrics
        [qMetric.isoD(iUnit), qMetric.Lratio(iUnit), qMetric.silhouetteScore(iUnit), ...
            qMetric.d2_mahal{iUnit}, qMetric.Xplot{iUnit}, qMetric.Yplot{iUnit}] = bc_getDistanceMetrics(pcFeatures, ...
            pcFeatureIdx, thisUnit, sum(spikeTemplates == thisUnit), spikeTemplates == thisUnit, spikeTemplates, param.nChannelsIsoDist, param.plotThis);
    end
end
if param.computeDistanceMetrics && ~isnan(param.isoDmin)
    unitType = nan(length(qMetric.percSpikesMissing),1);
    unitType(qMetric.nPeaks > param.maxNPeaks | qMetric.nTroughs > param.maxNTroughs | qMetric.somatic ~= param.somatic) = 0; %NOISE or NON-SOMATIC
    unitType(qMetric.percSpikesMissing <= param.maxPercSpikesMissing & qMetric.nSpikes > param.minNumSpikes & ...
        qMetric.nPeaks <= param.maxNPeaks & qMetric.nTroughs <= param.maxNTroughs & qMetric.Fp <= param.maxRPVviolations & ...
        qMetric.somatic == param.somatic & qMetric.rawAmplitude > param.minAmplitude & qMetric.isoDmin >= param.isoDmin) = 1;%SINGLE SEXY UNIT
    unitType(isnan(unitType)) = 2;% MULTI UNIT

else
    unitType = nan(length(qMetric.percSpikesMissing),1);
    unitType(qMetric.nPeaks > param.maxNPeaks | qMetric.nTroughs > param.maxNTroughs | qMetric.somatic ~= param.somatic) = 0; %NOISE or AXONAL
    unitType(qMetric.percSpikesMissing <= param.maxPercSpikesMissing & qMetric.nSpikes > param.minNumSpikes & ...
        qMetric.nPeaks <= param.maxNPeaks & qMetric.nTroughs <= param.maxNTroughs & qMetric.Fp <= param.maxRPVviolations & ...
        qMetric.somatic == param.somatic & qMetric.rawAmplitude > param.minAmplitude) = 1;%SINGLE SEXY UNIT
    unitType(isnan(unitType)) = 2;% MULTI UNIT

end
if exist('savePath', 'var') %save qualityMetrics
    mkdir(fullfile(savePath))
    disp(['saving quality metrics to ', savePath])
    save(fullfile(savePath, 'qMetric.mat'), 'qMetric','-v7.3')
    save(fullfile(savePath, 'param.mat'), 'param')
end
disp('finished extracting quality metrics')
if param.plotGlobal 
    % 1. multi-venn diagram of units classified as noise/mua by each quality metric
    colorMtx = [lines(7), repmat(0.6,7,1)];
    qMetric.nPeaks(1)=3;
    setsw = {find(qMetric.nPeaks > param.maxNPeaks),find(qMetric.nTroughs > param.maxNTroughs), ...
        find(qMetric.somatic == 0), find(qMetric.Fp > param.maxRPVviolations), ...
        find(qMetric.percSpikesMissing > param.maxPercSpikesMissing), ...
        find(qMetric.nSpikes <= param.minNumSpikes), find(qMetric.rawAmplitude <= param.minAmplitude)}; 
    
    figure();
    if 
    title('# of units classified as noise/mua/non-somatic with quality metrics')
    subplot(1,5,1:4)
    vennEulerDiagram(setsw,{'# peaks', '#troughs', 'non-somatic', 'refractory period violations','undetected spikes', '# spikes', 'waveform amplitude'},...
        'ColorOrder', colorMtx(:,1:3), ...
        'ShowIntersectionCounts',1);
    subplot(1,5,5) % hacky way to get a legend 
    set(gca, 'XColor', 'w','YColor', 'w')
    hold on;
    arrayfun(@(x) plot(NaN, NaN, 'linewidth', 2, 'color', colorMtx(x,:)), 1:7);
    legend({'# peaks', '#troughs', 'non-somatic', 'refractory period violations','undetected spikes', '# spikes', 'waveform amplitude'})
    set(gcf, 'color', 'w')
    
    % 2. histogram for each quality metric, red line indicates
    % classification threshold
    figure();
    set(gcf, 'color', 'w')
    
    subplot(4,2,1)
    title('# peaks'); hold on;
    histogram(qMetric.nPeaks, 'FaceColor', colorMtx(1,1:3), 'FaceAlpha', colorMtx(1,4));
    yLim = ylim;
    line([param.maxNPeaks+0.5, param.maxNPeaks+0.5], [0 yLim(2)], 'Color', 'r', 'LineWidth', 2)
    ylabel('unit count')
    xlabel('# peaks')
    
    subplot(4,2,2)
    title('# troughs'); hold on;
    histogram(qMetric.nTroughs, 'FaceColor', colorMtx(2,1:3), 'FaceAlpha', colorMtx(2,4));
    yLim = ylim;
    line([param.maxNTroughs+0.5, param.maxNTroughs+0.5], [0 yLim(2)], 'Color', 'r', 'LineWidth', 2)
    ylabel('unit count')
    xlabel('# troughs')
    
    subplot(4,2,3)
    title('# non-somatic'); hold on;
    histogram(1-qMetric.somatic, 'FaceColor', colorMtx(3,1:3), 'FaceAlpha', colorMtx(3,4));
    yLim = ylim;
    line([param.somatic-0.5, param.somatic-0.5], [0 yLim(2)], 'Color', 'r', 'LineWidth', 2)
    ylabel('unit count')
    xlabel('non somatic')
    
    subplot(4,2,4)
    title('% r.p.v.'); hold on;
    histogram(qMetric.Fp, 'FaceColor', colorMtx(4,1:3), 'FaceAlpha', colorMtx(4,4),'BinEdges', [0:5:max(qMetric.Fp)]);
    set(gca,'yscale','log')
    yLim = ylim;
    line([param.maxRPVviolations+0.5, param.maxRPVviolations+0.5], [yLim(1) yLim(2)], 'Color', 'r', 'LineWidth', 2)
    ylabel('unit count')
    xlabel('refractory period violations (%)')
    
    subplot(4,2,5)
    title('% undetected spikes'); hold on;
    histogram(qMetric.percSpikesMissing, 'FaceColor', colorMtx(5,1:3), 'FaceAlpha', colorMtx(5,4),'BinEdges', [0:5:max(qMetric.percSpikesMissing)]);
    yLim = ylim;
    line([param.maxPercSpikesMissing+0.5, param.maxPercSpikesMissing+0.5], [yLim(1) yLim(2)], 'Color', 'r', 'LineWidth', 2)
    ylabel('unit count')
    xlabel('spikes below detection threshold (%)')
    
    subplot(4,2,6)
    title('# spikes'); hold on;
    histogram(qMetric.nSpikes, 'FaceColor', colorMtx(6,1:3), 'FaceAlpha', colorMtx(6,4),'BinEdges', [0:300:max(qMetric.nSpikes)]);
    yLim = ylim;
    line([param.minNumSpikes+0.5, param.minNumSpikes+0.5], [yLim(1) yLim(2)], 'Color', 'r', 'LineWidth', 2)
    ylabel('unit count')
    xlabel('# spikes')
    
    subplot(4,2,7)
    title('waveform amplitude'); hold on;
    histogram(qMetric.rawAmplitude, 'FaceColor', colorMtx(6,1:3), 'FaceAlpha', colorMtx(6,4),'BinEdges', [0:20:max(qMetric.rawAmplitude)]);
    yLim = ylim;
    line([param.minAmplitude+0.5, param.minAmplitude+0.5], [yLim(1) yLim(2)], 'Color', 'r', 'LineWidth', 2)
    ylabel('unit count')
    xlabel('mean raw waveform peak amplitude (uV)')
    
    if param.computeDistanceMetrics && ~isnan(param.isoDmin)
        subplot(4,2,8)
        title('waveform amplitude'); hold on;
        histogram(qMetric.isoD, 'FaceColor', colorMtx(6,1:3), 'FaceAlpha', colorMtx(6,4),'BinEdges', [0:20:max(qMetric.isoD)]);
        yLim = ylim;
        line([param.minAmplitude+0.5, param.minAmplitude+0.5], [yLim(1) yLim(2)], 'Color', 'r', 'LineWidth', 2)
        ylabel('unit count')
        xlabel('mean raw waveform peak amplitude (uV)')
    end

end

end